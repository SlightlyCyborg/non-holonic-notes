Notes on the [[https://common-lisp.net/project/mcclim/static/documents/mcclim.pdf][McClim Manual]]

* Introduction
  
CLIM is a multilayer graphics system that is customizable at each layer.

The top layer contains:
- application frames
- panes
- gadgets

** How CLIM is Different

CLIM is not just a GUI toolkit, it is an interface manager. 
It manages everything at the software boundary between human and machine. 

Traditional GUI has an event loop and events are sent to widgets which are handled by event handlers.

Event-driven programming is seen as a virtue by GUI builders, but events are sent in a null context and therefore must be combined in the widget or by some hack.

CLIM has an event loop, but the user of the application layer uses a command loop.

The command loop does the following:
- Acquires command. (click, key, etc)
- Command is populated by arguments.
- Command is called on the arguments.
- A display routine updates the view of the application logic.
  
Instead of attaching event handlers, a CLIM app dev does the following:
- write CLIM commands that modify application data independently of how the command is evoked.
- write display routines that turn the application data into visible representations
- write completion routines (what are these??? IDK)
- attach commands to view objects and decide how the commands get evoked.

  
* User manual
** Building McCLIM
*** Examples and demos
McCLIM source comes with some demos and applications
They are available in Examples and Apps subdirectories
- clim-demo:demodemo

*** Applications
- Apps/Listener
- Apps/Inspector
- Apps/Debugger
  
** The First Application
*** Terminology
- application-frame: top level app
- panes: blocks to patition gadgets
- gadgets: the objects in the screen
  
*** How McCLIM produces output
    
    CLIM panes record the series of operations that generates a pixel based output.

**** Simple application:
     No internal data structure to keep track of application objects. 
     It simply produces output as a result of running commands.

**** Application with a static display function
     Some applications use a display function.
     A game of tic tac toe would use a display function to draw the board.

**** Applications with a dynamic display function
     This has internal data structures that has a direct mapping to output.
     Commands modify the internal structure.
     The display function is run after each command loop iteration
     
**** Applications with an incremental static display function
     This uses `updating-output` to only update output when needded.
     
**** Programmer does it all
     This way requires the programmer to keep track of all output records on the display list and to inform CLIM about modifications to it..

*** Panes and Gadgets

CLIM apps are made from a heirarchy of panes and gadgets

Frequently used gadgets:
- buttons
- sliders

Frequently used panes
- hbox
- vbox
- hrack
  
*** A First Attempt
#+BEGIN_SRC lisp
(in-package :common-lisp-user)

(defpackage :my-first-app
;; Imports the appropriate CLIM library
(:use :clim :clim-lisp)

;; The package will only export a function to run the app
(:export run-my-first-app))

;; Good practice
(in-package :my-first-app)

;; Definition of the structure of a minimum app
(define-application-frame my-first-clim-app ()
  ()
;; This app only has 1 pane
  (:panes
    (my-interactor :interactor
    :height 400
    :width 600))
    ;; :layouts section describes how the pane is positioned inside
    ;; the application frame.
    ;; With 1 pane, no point getting complicated, Default is fine...
    (:layouts
	(my-default my-interactor)))
;; Now that the structure of the app is defined, need a function
;; to launch an instance of this app. (The user could run
;; several instances of the same app.)
(defun run-my-first-app ()
   (run-frame-top-level (make-application-frame ’my-first-clim-app)))
#+END_SRC

The app uses two packages: clim and clim-lisp
- The clim packages contains all symbols needed for using clim
- the clim-lisp package replaces the common-lisp package. why?

The main function ~run-my-first-app~ is exported

The define-application-frame takes the following arguments:
- the name of the app
- aditional superclasses
- list of CLOS slots to be added.

The current application frame instance is held in ~*application-frame*~

The rest of the definition contains ~:panes~ and ~:layouts~

Each pane has a name, a type, and some other options used to instantiate that particular type of pane.

In the example there is a pane called ~int~ of type ~interactor~ that is 400 units by 600 units. 

The ~:layouts~ element defines how to organize panes into a hierarchy. Default is used here because we only have 1 pane.


*** Adding Functionality
An ~application-pane~ is subclass of a ~stream~ where application objects are placed.

Here is an improved example:
#+BEGIN_SRC lisp
(in-package :common-lisp-user)

(defpackage :my-first-app
;; Imports the appropriate CLIM library
(:use :clim :clim-lisp)

;; The package will only export a function to run the app
(:export run-my-first-app))

;; Good practice
(in-package :my-first-app)

;; Definition of the structure of a minimum app
(define-application-frame superapp ()
  ()
  (:pointer-documentation t)
  (:panes
    (int :interactor
    :height 200
    :width 600))
    
    (app :application
       :display-time nil
       :height 400
       :width 600)

    (:layouts
       (default (vertically ()
                    app int)))
		    
    (define-superapp-command (com-quit :name t) ()
        (frame-exit *application-frame*))
	
    (define-superapp-command (com-parity :name t) ((number 'integer))
        (format t "~a is ~a~%" number
           (if (oddp number)
	     "odd"
	     "even"))))
;; Now that the structure of the app is defined, need a function
;; to launch an instance of this app. (The user could run
;; several instances of the same app.)
(defun run-my-first-app ()
   (run-frame-top-level (make-application-frame ’my-first-clim-app)))
#+END_SRC

A new app pane was added.

~:display-time nil~ tells the pane not to clear after each iteration of the command loop.
This is important because there is no ~display~ function defined, so nothing would have been displayed without this option.

~define-<name>-command~ just defines a command.
